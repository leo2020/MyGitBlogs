<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>隐匿于黑夜中的星</title>
        <description>隐匿于黑夜中的星 - codepiano</description>
        <link>http://codepiano.github.io</link>
        <link>http://codepiano.github.io</link>
        <lastBuildDate>2013-08-13T04:40:37+08:00</lastBuildDate>
        <pubDate>2013-08-13T04:40:37+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>vim插件surround介绍</title>
                <description>

&lt;h3&gt;插件作者&lt;/h3&gt;
&lt;p class=&quot;paragraph&quot;&gt;
vim-surround是一个处理成对出现的“包围结构”的插件，比如处理括号、引号和html标签。对文本的外包的结构进行增加、修改和删除。
由于插件提供的命令接受vim文本对象和vim的移动命令，使用起来比较方便，额外的学习成本比较低。
插件的github地址为：&lt;a href=&quot;https://github.com/tpope/vim-surround&quot;&gt;tpope/vim-surround · GitHub&lt;/a&gt;
&lt;br /&gt;
作者是&lt;a href=&quot;http://tpo.pe/&quot;&gt;tpope&lt;/a&gt;，tpope贡献了很多实用的vim插件，他的github：&lt;a href=&quot;https://github.com/tpope&quot;&gt;tpope (Tim Pope) · GitHub&lt;/a&gt;
&lt;/p&gt;
&lt;h3&gt;普通模式命令&lt;/h3&gt;
普通模式下，插件提供下列按键绑定：
&lt;ul class=&quot;nav nav-tabs nav-stacked&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#cs&quot;&gt;cs 改变外部包围对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ds&quot;&gt;ds 删除外部包围对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ys&quot;&gt;ys 使用指定的符号包裹文本对象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;cs&quot;&gt;替换：change surround&lt;/h4&gt;
&lt;p class=&quot;paragraph&quot;&gt;
cs命令是change surround的缩写，可以对指定的文本的外部包围字符进行替换，命令接受两个参数：
第一个是被替换的外部包围字符，第二个是要替换为的字符。替换时光标需要移动到被包围的文本内。
比如需要将字符串'test'外部的包围字符'替换为&quot;，可以将光标移动到文本区域内，然后使用cs'&quot;即可
下面是一些例子，部分来自帮助文件，其中的*号代表光标位置
&lt;br /&gt;
&lt;span class=&quot;label label-important&quot;&gt;注意&lt;/span&gt; 命令中使用形如()、{}、[]的字符的左半部分和右半部分是有区别的，
区别在于处理中的头部和尾部的空格的处理，考虑例子6、7、8、9的情况，处理字符串(&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;)，
字符串有3个头部空格，有2个尾部空格。
&lt;br /&gt;
&lt;span class=&quot;label label-success&quot;&gt;规则&lt;/span&gt; 规则可以总结如下：
&lt;br /&gt;
1.第一个参数使用符号的左半部分，会自动删除所有的头部和尾部 的空格，使用右半部分则不对空格进行处理
&lt;br /&gt;
2.第二个参数使用符号的左半部分，会自动在左半部分的后面和右半部分的前面插入一个空格
&lt;br /&gt;
注意例子8中的空格个数，被自动插入了空格
&lt;/p&gt;
&lt;table class=&quot;table table-striped table-bordered&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;td&gt;样例序号&lt;/td&gt;
      &lt;td&gt;原始文本&lt;/td&gt;
      &lt;td&gt;执行命令&lt;/td&gt;
      &lt;td&gt;执行结果&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&quot;Hello*world!&quot;&lt;/td&gt;
      &lt;td&gt;cs&quot;'&lt;/td&gt;
      &lt;td&gt;'Helloworld!'&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&quot;Hello*world!&quot;&lt;/td&gt;
      &lt;td&gt;cs&quot;&amp;lt;q&amp;gt;&lt;/td&gt;
      &lt;td&gt;&amp;lt;q&amp;gt;Helloworld!&amp;lt;/q&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;(( Hello*world! ))&lt;/td&gt;
      &lt;td&gt;cs(*&lt;/td&gt;
      &lt;td&gt;(*Hello*world!*)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;(( Hello*world! ))&lt;/td&gt;
      &lt;td&gt;cs( *&lt;/td&gt;
      &lt;td&gt;(* Hello*world! *)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&amp;lt;div&amp;gt;Yo!*&amp;lt;/div&amp;gt;&lt;/td&gt;
      &lt;td&gt;cst&amp;lt;p&amp;gt;&lt;/td&gt;
      &lt;td&gt;&amp;lt;p&amp;gt;Yo!&amp;lt;/p&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;(&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;)&lt;/td&gt;
      &lt;td&gt;cs([&lt;/td&gt;
      &lt;td&gt;[ test ]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;(&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;)&lt;/td&gt;
      &lt;td&gt;cs(]&lt;/td&gt;
      &lt;td&gt;[test]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;(&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;)&lt;/td&gt;
      &lt;td&gt;cs)[&lt;/td&gt;
      &lt;td&gt;[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;&amp;nbsp;]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;(&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;)&lt;/td&gt;
      &lt;td&gt;cs)]&lt;/td&gt;
      &lt;td&gt;[&amp;nbsp;&amp;nbsp;&amp;nbsp;test &amp;nbsp;&amp;nbsp;]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;ds&quot;&gt;删除：delete surround&lt;/h4&gt;
&lt;p class=&quot;paragraph&quot;&gt;
ds命令是delete surround的缩写，该命令只接受一个参数，即为需要删除的外部包围字符
如果需要删除文本外部的标签，可以使用字符t来指代标签，不需要输入标签全称
下面是一些例子：
&lt;br /&gt;
&lt;span class=&quot;label label-important&quot;&gt;注意&lt;/span&gt; 命令中使用形如()、{}、[]的字符的左半部分和右半部分是有区别的，
规则同cs命令的规则1，即同样遵守第一个参数的规则，不再举例示范
&lt;/p&gt;
&lt;table class=&quot;table table-striped table-bordered&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;td&gt;样例序号&lt;/td&gt;
      &lt;td&gt;原始文本&lt;/td&gt;
      &lt;td&gt;执行命令&lt;/td&gt;
      &lt;td&gt;执行结果&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&quot;Hello*world!&quot;&lt;/td&gt;
      &lt;td&gt;ds&quot;&lt;/td&gt;
      &lt;td&gt;Hello world!&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;((Hello*world!))&lt;/td&gt;
      &lt;td&gt;ds{&lt;/td&gt;
      &lt;td&gt;(Hello*world!)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;(123+4*56)/2&lt;/td&gt;
      &lt;td&gt;ds)&lt;/td&gt;
      &lt;td&gt;123+456/2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&amp;lt;div&amp;gt;Yo!*&amp;lt;/div&amp;gt;&lt;/td&gt;
      &lt;td&gt;dst&lt;/td&gt;
      &lt;td&gt;Yo!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;ys&quot;&gt;添加：you surround&lt;/h4&gt;
&lt;p class=&quot;paragraph&quot;&gt;
ys命令是you surround（按作者的说法），可以对指定的文本进行包围，命令接受两个参数：
第一个是指示文本范围或者移动位置的文本对象，第二个是包围操作使用的字符。插入时光标需要移动到被包围的文本内。
比如需要将字符串test添加外部包围字符'，可以将光标移动到文本区域内，然后使用ysaw&quot;即可，其中aw会被当作vim文本对象，
ys模式有一种变形，即yss和ySS，操作的对象是当前行，不过yss的包围符号添加在行首行尾，而ySS的符号会插入两个新行来包围。
下面是一些例子，部分来自帮助文件，其中的*号代表光标位置
&lt;br /&gt;
指定范围的两种方法
&lt;br /&gt;
1.文本对象，规则基本同vim的文本对象规则一样
&lt;br /&gt;
2.移动位置，可以使用^、$、f等命令来指定位置，作用范围是当前光标到指定的位置
&lt;br /&gt;
&lt;span class=&quot;label label-important&quot;&gt;注意&lt;/span&gt; 命令中使用形如()、{}、[]的字符的左半部分和右半部分是有区别的，
规则同cs命令的规则2，即同样遵守第二个参数的规则，不再举例示范
&lt;/p&gt;
&lt;table class=&quot;table table-striped table-bordered&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;td&gt;样例序号&lt;/td&gt;
      &lt;td&gt;原始文本&lt;/td&gt;
      &lt;td&gt;执行命令&lt;/td&gt;
      &lt;td&gt;执行结果&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;ysiw'&lt;/td&gt;
      &lt;td&gt;'test'&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;'test'&lt;/td&gt;
      &lt;td&gt;ysi')&lt;/td&gt;
      &lt;td&gt;'(test)'&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;'test'&lt;/td&gt;
      &lt;td&gt;ysa')&lt;/td&gt;
      &lt;td&gt;('test')&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;foo*testbar&lt;/td&gt;
      &lt;td&gt;ystb)&lt;/td&gt;
      &lt;td&gt;foo(test)bar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;ysaw&amp;lt;p class=&quot;example&quot;&amp;gt;&lt;/td&gt;
      &lt;td&gt;&amp;lt;p class=&quot;example&quot;&amp;gt;test&amp;lt;/p&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;可视模式命令&lt;/h3&gt;
&lt;p class=&quot;paragraph&quot;&gt;
可视模式下可以选择需要的文本块，然后使用命令S，就可以输入用来进行包围的字符，不再赘述。
&lt;/p&gt;
&lt;h3&gt;插入模式命令&lt;/h3&gt;
&lt;p class=&quot;paragraph&quot;&gt;
插件的插入模式还处于试验状态，可以在插入模式下插入字符对，不过我并没有测试成功。通过map命令查看文档中的按键绑定，发现并未绑定函数。
&lt;/p&gt;
&lt;h3&gt;定制插件行为&lt;/h3&gt;
&lt;p class=&quot;paragraph&quot;&gt;
插件提供对符号的行为进行定制的功能，如果需要定制'-'符号在php文件中的功能，则按下面步骤操作
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;quot; 1.使用vim函数获得ascii码&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;echo char2nr&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot; 2.在vim文件中添加绑定，并使用文件类型侦测&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot; 注意b:surround_45使用了&amp;#39;-&amp;#39;的ascii码值45&lt;/span&gt;
autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; php &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;b&lt;/span&gt;:surround_45 &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;lt;?php \r ?&amp;gt;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
如果文件类型是php，则在字符串 print &quot;Hello *world!&quot;上执行yss-即可得到&amp;lt;?php print &quot;Hello world!&quot; ?&amp;gt;。使用如下方式还可以请求用户输入，jekyll的语法高亮使用highlight语法来完成，每次输入较麻烦，可以在vimrc中加入下面的设置
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;g&lt;/span&gt;:surround_45 &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;{% hightlight \1代码语言: \1 %}\r{% endhighlight %}&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p class=&quot;paragraph&quot;&gt;
这样就自定义了字符&quot;-&quot;的包围语法模板，比如在testtest上使用ySS-，会显示“代码语言：”并等待用户输入，输入bash，则得到下面的代码
其中的&quot;\1代码语言: \1&quot;被替换为用户输入的字符串，&quot;\r&quot;被替换为用户选择的需要被包围的文本，其余的均原样输出，
如果需要，可以在语法模板中使用换行等转义字符。语法模板也支持正则表达式的处理，但是语法过于古怪和丑陋，个人认为没有使用的价值。
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
  &lt;pre&gt;
{% highlight bash %}
testtest
{% endhighlight %}
  &lt;/pre&gt;
&lt;/div&gt;
</description>
                <link>http://codepiano.github.io/Vim/Vim Plugin/2013/08/12/vim-surround</link>
                <guid>http://codepiano.github.io/Vim/Vim Plugin/2013/08/12/vim-surround</guid>
                <pubDate>2013-08-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>推送git项目到多个远程仓库</title>
                <description>

&lt;p class=&quot;paragraph&quot;&gt;
最近&lt;a href=&quot;http://www.oschina.net/&quot;&gt;开源中国 - 找到您想要的开源项目，分享和交流&lt;/a&gt;也推出了git项目托管服务，
想把部分github中的项目同步到git@osc，在网上搜索了一下，找到了一种比较简单的同步办法，方法分享在下面。
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
首先强烈推荐实用ssh的方式来完成push过程中的认证，这样不用每次都输入用户名和密码，十分方便。具体方式可以参考github的
官方教程&lt;a href=&quot;https://help.github.com/articles/generating-ssh-key&quot;&gt;GitHub Help&lt;/a&gt;
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
如果已经配置好了ssh验证方式，在开源中国的git托管也可以使用同一个的key，然后打开github项目中中的.git/config文件
在[remote &quot;origin&quot;]节点的原始url下面直接添加开源中国git中对应项目的ssh地址即可，例如：
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;
[remote &quot;origin&quot;]
	url = git@github.com:codepiano/pull-all-git-project.git
	url = git@git.oschina.net:codepiano/pull-all-git-project.git
	fetch = +refs/heads/*:refs/remotes/origin/*
&lt;/pre&gt;
&lt;/div&gt;
&lt;p class=&quot;paragraph&quot;&gt;
当然，使用命令行也可以直接添加，命令格式如下：
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git remote &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;-url --add origin git@git.oschina.net:codepiano/pull-all-git-project.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


</description>
                <link>http://codepiano.github.io/Git/2013/07/03/push-multi-remote-repositories</link>
                <guid>http://codepiano.github.io/Git/2013/07/03/push-multi-remote-repositories</guid>
                <pubDate>2013-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim zencoding插件的一个bug的跟踪和解决过程</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
前几天用vim写博客的过程中发现一个bug，当使用&amp;lt;c-y&amp;gt;a自动生成a标签的时候，会丢失href元素，
就跟踪了下那个函数的调用过程。找着bug的原因后，在github上给zencoding的作者发了一个pull request，
不过由于作者想更深层修复缺陷，没有merge，给转成issue了。把具体的跟踪过程和分析记录在这里
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
&amp;lt;c-y&amp;gt;a是个很好用的命令，比如你准备插入一个a标签，只用输入http://www.vim.org，
然后使用zencoding扩展，会自动生成a标签，插件会联网读取那个网址的title标签，
并使用标签内容作为a标签的显示内容:
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;http://www.vim.org&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;welcome home : vim online&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
不过我使用的时候遇到一个bug，生成的a标签会丢失href属性，想寻找bug出现的原因就要跟踪代码调用过程。
使用&amp;lt;c-y&amp;gt;a标签的时候在vim状态栏可以看到调用了zencoding#anchorizeURL函数，并传入了一个参数，
值为0。而zencoding插件的初始化操作在plugin/zencoding.vim文件中，顶层函数放在autoload/zencoding.vim中，
具体的处理标签的底层操作逻辑分散放在autoload/zencoding目录中。先从autoload/zencoding.vim入手，
找到了zencoding#anchorizeURL函数，通过阅读代码找到如下逻辑：
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;quot; file:autoload/zencoding.vim&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;quot; a:flag即为传入的参数，当调用&amp;lt;c-y&amp;gt;a时为0，调用&amp;lt;c-y&amp;gt;A时为1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt;:flag &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; 生成a标签的属性字典&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; zencoding#&lt;span class=&quot;k&quot;&gt;lang&lt;/span&gt;#html#parseTag&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;lt;a&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt;.attr.href &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; url
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt;.value &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;{&amp;#39;&lt;/span&gt; . &lt;span class=&quot;nb&quot;&gt;title&lt;/span&gt; . &lt;span class=&quot;s1&quot;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; 根据属性字典生成html代码&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; expand &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; zencoding#toString&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; rtype&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; []&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; 去除代表光标位置的标志符号&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; expand &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; substitute&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;expand&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;\${cursor}&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
通过分析上面这段代码，可以知道问题应该处在zencoding#toString函数中，不过通过分析该函数的代码，
发现这个函数只是一个顶层函数，根据上步调用传入的属性字典的name或者snippts属性来决定是调用底层工具函数来生成代码，
还是通过自定义snippts进行扩展。结合传入参数和程序逻辑，在这个功能中，是调用了底层工具函数zencoding#lang#html#toString，
该函数位于autoload/zencoding/lang/html.vim中。函数中有下面这段代码
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;quot; file:autoload/zencoding/lang/html.vim&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; len&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current_name&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; str .&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt; . current_name
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; attr &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; zencoding#util#unique&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current.attrs_order&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;has_key&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current.attr&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; attr&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      continue
    &lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;    &amp;quot; ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;endfor&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
出现href属性丢失的原因是因为current.attrs_order为空，没有'href'属性名字符串，
所以生成的标签也不存在href属性。
也就是说由于程序缺陷，导致属性字典中代表标签属性列表的数组attrs_order为空。
由于我并没有深层次的去读插件的源码，所以不了解这个数组为空的原因，
而autoload/zencoding.vim中的zencoding#anchorizeURL函数只处理a标签的扩展，
所以我直接在顶层函数zencoding#anchorizeURL中给attrs_order中add了一个值'href'，
这样可以解决这一个小问题。后来给插件作者发了pull request，说明了bug的原因，
并指出不确定是不是最好的解决方式，插件作者回复说他想从本质上解决这个问题，
把我的pull request转成了issue。一开始我以为作者会去解决attrs_order数组为空的问题，
不过pull最新的代码，发现作者也没去修改attrs_order数组，而是在底层的工具函数上打了个补丁，
修改后的代码如下
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;quot; file:autoload/zencoding/lang/html.vim&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; len&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current_name&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; str .&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt; . current_name
&lt;span class=&quot;c&quot;&gt;  &amp;quot; 打了个keys(current.attr)的补丁，补全了属性&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; attr &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; zencoding#util#unique&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current.attrs_order &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; keys&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;current.attr&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; val &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; current.attr[attr]
&lt;span class=&quot;c&quot;&gt;    &amp;quot; ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;endfor&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;  &amp;quot; ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
关于这次的bug修改，让我想起看过的伞哥 &lt;a href=&quot;http://weibo.com/tianchunbinghe&quot;&gt;@田春冰河&lt;/a&gt; 的一条微博说过的一种情况，
微博找不到了，大意是说：一个工具模块的代码缺陷A，导致不同的功能中出现bug的并集U，
测试人员通过测试发现其中一个子集u，然后开发人员修复子集u中的bug，
而真正好的解决方式是通过bug集u找到问题的源头，即缺陷A，从而修复整个bug集U。
这次的情况也类似，我只修复了a标签生成这一个bug，作者修改底层模块后也修复了潜在的其他bug
&lt;/p&gt;
</description>
                <link>http://codepiano.github.io/Vim/Vimscript/2013/05/27/bug-trace-of-vim-zencoding-plugin</link>
                <guid>http://codepiano.github.io/Vim/Vimscript/2013/05/27/bug-trace-of-vim-zencoding-plugin</guid>
                <pubDate>2013-05-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>生成表格边框的vim插件</title>
                <description>

&lt;p class=&quot;paragraph&quot;&gt;
vim插件，惟一用途是在文本文件中来展示表格，使用字符来模拟表格的边框。会破坏原始数据，不便于复制，
请谨慎使用。由于字符的展示方式与字体有关，可能某些字体下边框不能完美的对齐。
项目地址:&lt;a href=&quot;https://github.com/codepiano/TableKnight&quot;&gt;codepiano/TableKnight · GitHub&lt;/a&gt;
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
插件会根据分隔符自动分割选定的文本行，然后插入边框字符。例如：下面的字符
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;
1|2
|1|2|||3
1|2|3|4|5
&lt;/pre&gt;
会生成：
&lt;pre&gt;
+===========+
|1|2| | | | |
|-+-+-+-+-+-|
| |1|2| | |3|
|-+-+-+-+-+-|
|1|2|3|4|5| |
+===========+
&lt;/pre&gt;
&lt;/div&gt;
&lt;p class=&quot;paragraph&quot;&gt;
插件提供了边框和分割符的自定义机制，具体请参考README
&lt;/p&gt;

</description>
                <link>http://codepiano.github.io/Vim/Vimscript/2013/05/06/vim-plugin-generate-table-border-with-symbol</link>
                <guid>http://codepiano.github.io/Vim/Vimscript/2013/05/06/vim-plugin-generate-table-border-with-symbol</guid>
                <pubDate>2013-05-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>更新路径下所有git项目和项目中的子模块</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
在给定目录的所有子文件夹下执行git pull，如果你签出的项目都在一个或几个目录下，
例如，你使用git clone命令签出了4个项目到F:\GIT目录下：
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;
F:\GIT

├─JQuerySourceCode

├─pull-all-git-project

├─RapidValidation

└─TableKnight
&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
可以在脚本的配置变量中添加路径：F:\GIT，执行脚本就可以依次在每个目录中进行下列操作，先更新项目，
如果项目包含子模块再更新所有子模块。&lt;b&gt;注意:更新默认的分支都是主分支&lt;/b&gt;
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 下面两个命令在项目中执行&lt;/span&gt;
git pull origin master
git submodule foreach pull git origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p class=&quot;paragraph&quot;&gt;
脚本提供了Windows版的bat文件和Linux下的Bash文件，两个脚本行为一样，由于脚本语言的差异，
配置方式有一些不同，具体请参考README。如果发现子模块无法更新，请手动在项目中执行下面两个命令，
然后再进行尝试:
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git submodule init
git submodule update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


</description>
                <link>http://codepiano.github.io/Code/Script/2013/04/04/pull-all-git-project</link>
                <guid>http://codepiano.github.io/Code/Script/2013/04/04/pull-all-git-project</guid>
                <pubDate>2013-04-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>将rapid validation的库依赖从prototype.js迁移到jquery</title>
                <description>

&lt;p class=&quot;paragraph&quot;&gt;该项目是由baiqiu编写的RapidValidation校验框架，框架原始的依赖是prototype.js，
为了以后维护和改造,将库的依赖替换成了jQuery，目前已完成了基本功能的改造,去掉了tooltip和effect，
项目地址：&lt;a href=&quot;https://github.com/codepiano/RapidValidation&quot;&gt;codepiano/RapidValidation · GitHub&lt;/a&gt;
&lt;/p&gt;

&lt;h2&gt;
&lt;a name=&quot;&quot; class=&quot;anchor&quot; href=&quot;#&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;原始作者:&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;modified by badqiu (badqiu(a)gmail.com)&lt;/p&gt;
&lt;p&gt;blog: &lt;a href=&quot;http://badqiu.javaeye.com&quot;&gt;badqiu - ITeye技术网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Project Home: &lt;a href=&quot;http://code.google.com/p/rapid-validation/&quot;&gt;rapid-validation - Rapid javascript validation framework - Google Project Hosting &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rapid Framework Project Home: &lt;a href=&quot;http://code.google.com/p/rapid-framework/&quot;&gt;rapid-framework - java web快速开发脚手架 - Google Project Hosting &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Version 1.5.1&lt;/p&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://codepiano.github.io/Web/Javascript/2012/11/26/change-rapid-validation-dependence-to-jquery</link>
                <guid>http://codepiano.github.io/Web/Javascript/2012/11/26/change-rapid-validation-dependence-to-jquery</guid>
                <pubDate>2012-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在cmd命令行下快速切换工作目录</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
有时候会碰到需要在cmd里面切换工作路径的需求，而目录的层数又比较深，于是写了这个脚本，
可以存储路径，并切快速切换
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
建议放置在windows/system32目录下面，或者将脚本所在文件夹加入path，
这样可以直接在终端里面输入ls或者po调用脚本，使用的时候按0增加目录名称和地址，
脚本启动的时候会打印出所有存储的路径，可以直接输入编号进行工作路径的切换
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
ls.bat可以在cmd里面切换工作路径，po.bat可以直接打开路径对应的文件夹，使用方式相同
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
目前没有做删除目录地址的功能，可以通过手动修改path.txt删除目录地址，path.txt和脚本在同一目录下
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
项目地址:&lt;a href=&quot;https://github.com/codepiano/GuideBoard&quot;&gt;codepiano/GuideBoard · GitHub&lt;/a&gt;
&lt;/p&gt;

</description>
                <link>http://codepiano.github.io/Code/Script/2012/06/29/quickly-change-working-dir-in-cmd</link>
                <guid>http://codepiano.github.io/Code/Script/2012/06/29/quickly-change-working-dir-in-cmd</guid>
                <pubDate>2012-06-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>《编程珠玑》习题-如何用位逻辑实现位向量</title>
                <description>

&lt;p class=&quot;paragraph&quot;&gt;
《编程珠玑》第一章提到了一个排序问题，具体需求抄在下面：
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
  输入：一个最多包含n个正整数的文件，每个数都小于n，其中n=107。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
  输出：按升序排列的输入整数的列表。
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
  约束：最多有（大约）1MB的内存空间可用，有充足的磁盘存储空间可用。运行时间最多几分钟，运行时间为10秒就不需要进一步优化了。
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
整个解题的思路是通过位向量来进行排序，使用107个位来代表从0～107的数，如果文件中包含数n，则将第n位置为1，
输出的时候按序遍历每一位，如果该位为1就输出该位的序号，即可得到最后的排序序列。
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
书中实现位向量是通过整数数组来实现的，或许是因为c语言中没有位向量这个数据结构，
c++中的标准模板库已经提供了bitset这个数据结构。 实现的原理如下：
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
由于一个整型是32位，所以只需定义一个长度为107/32的整型数组即可提供所需的二进制位，整数数组记为A。
从输入文件中读入一个整数，将这个整数整除32，得到的结果即是表示该数存在的二进制位记录在数组的哪个下标的整数中，
比如111，用111整除32得3，即代表该数存在的二进制位在数组下标为3的数，即A[3]中。
将读入的数模32，得到的数即为代表该数的标志位在A[3]中的位置，比如111模32结果为15，
则将A[3]的第15位置为1，即A[3]现在为00000000000000000100000000000000，即为32768
如此即可使用整型数组模拟位集合，比如读入的第二个数为127，127整除32为3，模32为31，则A[3]为10000000000000000100000000000000
代码如下：
&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//一个整型有32位&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define BITSPERWORD 32&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//定义移位的长度，2的5次方为32&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define SHIFT 5&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//定义取模的掩码&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define MASK 0x1F&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//输入文件中整数的最大范围&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define N 10000000&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//定义存储的数组&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BITSPERWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *根据参数i，设置对应的标志位的值&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *i&amp;gt;&amp;gt;SHIFT，i右移5位，相当于i/32&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *i &amp;amp; MASK，i和11111做与运算，得到i%32&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *1&amp;lt;&amp;lt;(i &amp;amp; MASK)，1左移(i%32)位，将结果与a[i&amp;gt;&amp;gt;SHIFT]做或运算&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *即可设置整数i对应的标志位为1&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SHIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *根据参数i，设置对应的标志位为0&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SHIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; *根据参数i，判断对应的标志位是否为1&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SHIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>http://codepiano.github.io/Code/C/2012/05/08/sort-large-number-of-integers</link>
                <guid>http://codepiano.github.io/Code/C/2012/05/08/sort-large-number-of-integers</guid>
                <pubDate>2012-05-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>100个常用的vim命令中文版</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
这篇文章被标题党冠以《程序员应该知道的100个vim命令》在网上流传，其实这些命令对速成有些帮助，
在加深对vim的理解方面没有太大用处。想用好查找替换功能就必须能熟练写正则表达式，
想方便的操作文件就必须对shell命令有了解，想写程序方便就要装插件模拟IDE的功能，
有些功能可能还要自己动手写shell脚本或者插件在vim中进行调用
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
从我自己的经验看来，想用好vim，就必须理解vim命令的设计风格，看几遍vim帮助文档，经常使用，
学习vimscript，没有任何可以速成的方法
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
这个文章作为tips也不合格，完全不如这篇 &lt;a href=&quot;http://www.rayninfo.co.uk/vimtips.html&quot;&gt;Best of VIM Tips, gVIM's Key Features zzapper&lt;/a&gt;。
作者说自己是一个有15年vi经验和7年vim经验并且还在继续学习的人
&lt;/p&gt;
&lt;p class=&quot;paragraph&quot;&gt;
翻译到一半觉得这篇文章完全没有翻译的价值，不过还是继续翻译完了，地址: &lt;a href=&quot;/pages/100-vim-commands.html&quot;&gt;常用的vim命令&lt;/a&gt;
&lt;/p&gt;

</description>
                <link>http://codepiano.github.io/Vim/Tips/2012/04/04/100-vim-commands</link>
                <guid>http://codepiano.github.io/Vim/Tips/2012/04/04/100-vim-commands</guid>
                <pubDate>2012-04-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim中添加快速单词查询功能</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
本文内容转载整理自网上的文章，&lt;a href=&quot;http://wiki.hotoo.me/Vim.html&quot;&gt;Vim - 闲耘™.Wiki&lt;/a&gt; &gt; 其它技巧 &gt; 翻译取词，原始作者不详
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
从github上下载的一些开源项目提供的文档是英文的，在vim里面看文档遇到不认识的单词还得用鼠标取词去查询，
特别不方便。于是去网上找给vim添加便捷单词查询功能的方法，整理在下面
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
首先需要安装一个shell下运行的词典工具stardict，可以使用下面的命令来安装
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo apt-get install sdcv stardict stardict-tools 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p class=&quot;paragraph&quot;&gt;
安装完成后可以在shell里面使用sdcv命令来查询单词，stardict并没有自带字典文件，需要自己去下载字典文件，
可以用搜索引擎搜索stardict-langdao-ec-gb-2.4.2.tar.bz2来寻找字典数据包的下载地址，
将下载下来的包解压后放入/usr/share/stardict/dic中，这里可能会碰到权限问题，可以用命令来完成。
现在使用sdcv命令查询单词就能出现内容了
&lt;/p&gt;


&lt;div class=&quot;highlight&quot;&gt;
  &lt;pre&gt;
ubuntu:~1 sdcv terminal
Found 1 items, similar to terminal.
--&gt;朗道英汉字典5.0
--&gt;terminal
['tә:minәl]
n. 终端机, 终点, 末端, 极限, 终点站
a. 终点的, 定期的, 致死的, 结尾的, 末端的, 晚期的
【计】 终端; 终端设备
【化】 接线端
【医】 终末的, 末端, 端
【经】 终站, 终点, 定期
  &lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;paragraph&quot;&gt;
下面就是给vim添加命令，让vim调用shell命令去查询单词，把结果显示到vim中，在vimrc中添加下面的函数，
需要查词的时候把光标移动到要查的词内，默认使用&amp;lt;leader&amp;gt;f进行查询，在左侧会打开一个窗口，显示查询结果。
快捷键和窗口的设置都可以通过修改下面的函数来进行自定义。网上提供的函数代码，打开查询结果的窗口后光标也会跟随到新窗口去，
还需要再通过命令跳转回文本窗口，不是很方便。我在函数后面加了一行命令 &quot;wincmd p&quot;，来跳转回刚才的窗口，这样查词就方便多了
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt; Mydict&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;执行sdcv命令查询单词的含义,返回的值保存在expl变量中&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; expl&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;system&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;sdcv -n &amp;#39;&lt;/span&gt; . expand&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;在每个窗口中执行命令，判断窗口中的文件名是否是dict-tmp，如果是，强制关闭&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;windo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; expand&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;%&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)==&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;dict-tmp&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!|&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;	
&lt;span class=&quot;c&quot;&gt;&amp;quot;纵向分割窗口，宽度为25，新窗口的内容为dict-tmp文件的内容&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;25&lt;/span&gt;vsp &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;tmp
&lt;span class=&quot;c&quot;&gt;&amp;quot;设置查询结果窗口的属性，不缓存，不保留交换文件&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;buftype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;nofile &lt;span class=&quot;nb&quot;&gt;bufhidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;hide&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;noswapfile&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;将expl的内容显示到查询结果窗口&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;s&lt;span class=&quot;sr&quot;&gt;/^/&lt;/span&gt;\&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;expl/
&lt;span class=&quot;c&quot;&gt;&amp;quot;跳转回文本窗口&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;wincmd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;p&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;按键绑定，将调用函数并执行&lt;/span&gt;
nmap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;leader&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;f&lt;/span&gt; :&lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; Mydict&lt;span class=&quot;p&quot;&gt;()&amp;lt;&lt;/span&gt;CR&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


</description>
                <link>http://codepiano.github.io/Vim/Vimscript/2012/03/24/translate-word-under-cursor-in-vim</link>
                <guid>http://codepiano.github.io/Vim/Vimscript/2012/03/24/translate-word-under-cursor-in-vim</guid>
                <pubDate>2012-03-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>JQuery DataTables插件中文文档</title>
                <description>

&lt;p class=&quot;paragraph&quot;&gt;
下面内容翻译自官网:
&lt;a href=&quot;http://www.datatables.net/&quot;&gt;DataTables (table plug-in for jQuery)&lt;/a&gt; 是一个jQuery的表格插件。
是以渐进增强理念为基础构建的一个高度灵活的工具，可以在任何HTML表格上实现高级交互控制。
抽时间将帮助文档翻译成了中文版，地址： &lt;a href=&quot;/pages/jquery-datatables-config-cn.html&quot;&gt;JQuery-DataTables插件中文文档&lt;/a&gt;
&lt;/p&gt;
&lt;h4&gt;主要特点：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;可变长度分页&lt;/li&gt;
  &lt;li&gt;即时表格数据过滤&lt;/li&gt;
  &lt;li&gt;与数据类型自动检测相结合的多列排序&lt;/li&gt;
  &lt;li&gt;智能处理列宽&lt;/li&gt;
  &lt;li&gt;可以从几乎任何数据源加载数据(DOM,Javascript array,Ajax file and server-side processing)&lt;/li&gt;
  &lt;li&gt;表单视图的滚动配置&lt;/li&gt;
  &lt;li&gt;完全国际化&lt;/li&gt;
  &lt;li&gt;jQuery UI ThemeRoller支持&lt;/li&gt;
  &lt;li&gt;健壮性，背后是2900项单元测试&lt;/li&gt;
  &lt;li&gt;丰富的插件&lt;/li&gt;
  &lt;li&gt;免费&lt;/li&gt;
  &lt;li&gt;表格状态保持&lt;/li&gt;
  &lt;li&gt;隐藏列&lt;/li&gt;
  &lt;li&gt;动态创建表格&lt;/li&gt;
  &lt;li&gt;Ajax自动加载数据&lt;/li&gt;
  &lt;li&gt;自定义DOM元素的位置&lt;/li&gt;
  &lt;li&gt;单列过滤&lt;/li&gt;
  &lt;li&gt;自定义的分页类型&lt;/li&gt;
  &lt;li&gt;非侵入式的DOM交互&lt;/li&gt;
  &lt;li&gt;高亮排序的列&lt;/li&gt;
  &lt;li&gt;先进的数据源控制&lt;/li&gt;
  &lt;li&gt;提供商业支持&lt;/li&gt;
  &lt;li&gt;提供屏幕阅读器和键盘支持&lt;/li&gt;
  &lt;li&gt;压缩后70K，gzip压缩后20k&lt;/li&gt;
  &lt;li&gt;多种扩展插件支持&lt;/li&gt;
  &lt;li&gt;丰富的文档&lt;/li&gt;
  &lt;li&gt;130多个样例&lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://codepiano.github.io/Web/Javascript/2012/03/02/jquery-datatables-config-cn</link>
                <guid>http://codepiano.github.io/Web/Javascript/2012/03/02/jquery-datatables-config-cn</guid>
                <pubDate>2012-03-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>人人网主页在遨游浏览器内超级拖放功能失效</title>
                <description>


&lt;p class=&quot;paragraph&quot;&gt;
很少在人人网主页使用超级拖放功能进行搜索，今天同学发了一条状态，“6.73很欢乐”。
不知道6.73是什么意思，拖放搜了下，没出结果，我也没在意，直接又选中文字右键搜了下。
排名第一的居然是豆瓣的一个帖子 ，说是Dota出6.73版了
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
后来同学回复我的状态说超级拖放不能用了，才想着看看是哪的问题。遨游的这类附加功能应该也是监听事件来实现的，
去w3cshool查DOM和javascript中对的事件的支持，并没有拖放事件。不过遨游兼容模式是IE内核，极速模式是WEBKit内核，
去网上搜 &quot;IE 拖放事件&quot;，查出来微软在IE里面增加了拖放事件的监听，搜weikit支持的事件，也有对拖放事件的支持。
这样问题就大概清楚了，估计是人人网的javascript脚本拦截或者覆盖了拖放事件，导致遨游浏览器收不到触发的拖放事件，
所以拖放后没有任何反应
&lt;/p&gt;

&lt;p class=&quot;paragraph&quot;&gt;
用遨游自带的开发者工具看了看人人网js脚本里监听的事件，发现home.js中有代码监听了dragover事件，代码如下：
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_8f8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;_8f8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;dragover&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p class=&quot;paragraph&quot;&gt;
就是这段代码造成超级拖放失效，代码获取了document的body节点，然后附加拖放事件的监听，如果拖放事件发生了，
代码会调用后面的匿名函数进行处理，e.preventDefault()拦截了事件，通知浏览器不要执行与事件关联的默认动作，
所以当拖放操作发生后，遨游收不到拖放操作发生的通知。 通过实验验证，把人人网主页另存到本地，找到这段代码，
把e.preventDefault()删除，然后再打开就能进行正常的超级拖放。 综合附近的代码来看，监听器是为了实现拖放图片上传的功能
&lt;/p&gt;
</description>
                <link>http://codepiano.github.io/Web/Javascript/2011/12/25/super-drag-invalid-in-renren-homepage-with-maxthon</link>
                <guid>http://codepiano.github.io/Web/Javascript/2011/12/25/super-drag-invalid-in-renren-homepage-with-maxthon</guid>
                <pubDate>2011-12-25T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
